/**
 * Copyright (c) 2020, Cristina Ruiz Martin
 * ARSLab - Carleton University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/**
* Model developed by Hoda Khalil in Cell-DEVS CD++
* Implemented in Cadmium-cell-DEVS by Cristina Ruiz Martin
*/

#ifndef CADMIUM_CELLDEVS_CO2_CELL_HPP
#define CADMIUM_CELLDEVS_CO2_CELL_HPP

#include <cmath>
#include <nlohmann/json.hpp>
#include <random>
#include <cadmium/celldevs/cell/grid_cell.hpp>

using nlohmann::json;
using namespace cadmium::celldevs;

std::list<std::pair<char,std::tuple<int,int,int>>> nextCO2Position; //List include the next action for CO2_Source movement <action(+:Appear CO2_Source;-:Remove CO2_Source),<xPosition,yPosition>>

/************************************/
/******COMPLEX STATE STRUCTURE*******/
/************************************/
enum CELL_TYPE {AIR=-100, CO2_SOURCE=-200, IMPERMEABLE_STRUCTURE=-300, DOOR=-400, WINDOW=-500, VENTILATION=-600, WORKSTATION=-700};
struct co2 {
    int counter;
    int concentration;
    CELL_TYPE type;
    co2() : counter(-1), concentration(500), type(AIR) {}  // a default constructor is required
    co2(int i_counter, int i_concentration, CELL_TYPE i_type) : counter(i_counter), concentration(i_concentration), type(i_type) {}
};
// Required for comparing states and detect any change
inline bool operator != (const co2 &x, const co2 &y) {
    return x.counter != y.counter || x.concentration != y.concentration || x.type != y.type;
}
// Required if you want to use transport delay (priority queue has to sort messages somehow)
inline bool operator < (const co2& lhs, const co2& rhs){ return true; }

// Required for printing the state of the cell
std::ostream &operator << (std::ostream &os, const co2 &x) {
    os << "<" << x.counter << "," << x.concentration << "," << x.type <<">";
    return os;
}

// Required for creating co2 objects from JSON file
void from_json(const json& j, co2 &s) {
    j.at("counter").get_to(s.counter);
    j.at("concentration").get_to(s.concentration);
    j.at("type").get_to(s.type);
}

/************************************/
/******COMPLEX CONFIG STRUCTURE******/
/************************************/
struct conc {
    float conc_increase; //CO2 generated by one person
    int base; //CO2 base level
    int window_conc; //CO2 level at window
    int vent_conc; //CO2 level at vent
    int resp_time;
    // Each cell is 25cm x 25cm x 25cm = 15.626 Liters of air each
    // CO2 sources have their concentration continually increased by default by 12.16 ppm every 5 seconds.
    conc(): conc_increase(121.6*2), base(500), resp_time(5), window_conc(400), vent_conc(300) {}
    conc(float ci, int b, int wc, int vc, int r): conc_increase(ci), base(b), resp_time(r), window_conc(wc), vent_conc(vc) {}
};
void from_json(const json& j, conc &c) {
    j.at("conc_increase").get_to(c.conc_increase);
    j.at("base").get_to(c.base);
    j.at("resp_time").get_to(c.resp_time);
    j.at("window_conc").get_to(c.window_conc);
    j.at("vent_conc").get_to(c.vent_conc);
}


template <typename T>
class co2_lab_cell : public grid_cell<T, co2> {
public:
    using grid_cell<T, co2, int>::simulation_clock;
    using grid_cell<T, co2, int>::state;
    using grid_cell<T, co2, int>::map;
    using grid_cell<T, co2, int>::neighbors;

    using config_type = conc;  // IMPORTANT FOR THE JSON
    float  concentration_increase; //// CO2 sources have their concentration continually increased
    int base; //CO2 base level
    int resp_time; //Time used to calculate the concentration inscrease
    int window_conc; //CO2 level at window
    int vent_conc; //CO2 level at cent


    co2_lab_cell() : grid_cell<T, co2, int>() {
    }

    co2_lab_cell(cell_position const &cell_id, cell_unordered<int> const &neighborhood, co2 initial_state,
                 cell_map<co2, int> const &map_in, std::string const &delayer_id, conc config) :
            grid_cell<T, co2>(cell_id, neighborhood, initial_state, map_in, delayer_id) {
        concentration_increase = config.conc_increase;
        base = config.base;
        resp_time = config.resp_time;
        window_conc = config.window_conc;
        vent_conc = config.vent_conc;

        if(initial_state.type == CO2_SOURCE) {
            std::pair<char, std::tuple<int, int, int>> intiAction;
            intiAction.first = '-';
            std::get<0>(intiAction.second) = cell_id[0];
            std::get<1>(intiAction.second) = cell_id[1];
            std::get<2>(intiAction.second) = cell_id[2];
            nextCO2Position.push_back(intiAction);
        }

    }

    co2 local_computation() const override {
        co2 new_state = state.current_state;

        

        std::tuple<int,int, int> currentLocation;
        std::get<0>(currentLocation) = this->map.location[0];
        std::get<1>(currentLocation) = this->map.location[1];
        std::get<2>(currentLocation) = this->map.location[2];

    std::random_device dev;
    std::mt19937 rng(dev());
    std::uniform_int_distribution<int> distneg(-70,70);


        switch(state.current_state.type){
            case IMPERMEABLE_STRUCTURE:
                new_state.concentration = 0;
                break;
            case DOOR:
                new_state.concentration = base;
                break;
            case WINDOW:
                new_state.concentration = window_conc;
                break;
            case VENTILATION:
                new_state.concentration = vent_conc;
                break;
            case AIR:{
                int concentration = 0;
                int num_neighbors = 0;
                for(auto neighbors: state.neighbors_state) {
                    if( neighbors.second.concentration < 0){
                        assert(false && "co2 concentration cannot be negative");
                    }
                    if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
                            // Neighbor on top
                            if (neighbors.first[0] == std::get<0>(currentLocation) && (neighbors.first[1] - 1) == std::get<1>(currentLocation)){
                                if(neighbors.second.concentration>500){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );  
                                }
                                else{
                                    concentration += neighbors.second.concentration;
                                }
                                num_neighbors +=1;
                            }
                            // Neighbor on right
                            else if((neighbors.first[0] - 1) == std::get<0>(currentLocation) && neighbors.first[1] == std::get<1>(currentLocation)){
                                if(neighbors.second.concentration>500){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                }
                                else{
                                    concentration += neighbors.second.concentration;
                                }
                                num_neighbors +=1;
                                
                            }
                            // Neighbor on bottom
                            else if (neighbors.first[0] == std::get<0>(currentLocation) && (neighbors.first[1] + 1) == std::get<1>(currentLocation)){
                                if(neighbors.second.concentration>500){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                }
                                else{
                                    concentration += neighbors.second.concentration;
                                }
                                num_neighbors +=1;      
                            }
                            // Neighbor on left
                            else if((neighbors.first[0] + 1) == std::get<0>(currentLocation) && neighbors.first[1] == std::get<1>(currentLocation)){
                                if(neighbors.second.concentration>500){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                }
                                else{
                                    concentration += neighbors.second.concentration;
                                }
                                num_neighbors +=1;
                              
                            }
                            // Itself
                            else if(neighbors.first[0] == std::get<0>(currentLocation) && neighbors.first[1] == std::get<1>(currentLocation) && neighbors.first[2] == std::get<2>(currentLocation)){
                                if(neighbors.second.concentration>500){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                }
                                else{
                                    concentration += neighbors.second.concentration;
                                }
                                num_neighbors +=1;
                               
                            }
                            // Above Neighbor
                            else if((neighbors.first[2] - 1) == std::get<2>(currentLocation)){
                                
                                if(neighbors.second.concentration>500){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                }
                                else{
                                    concentration += neighbors.second.concentration;
                                }
                                num_neighbors +=1;

                            }
                            // Behind Neighbor
                            else if((neighbors.first[2] + 1) == std::get<2>(currentLocation)){
                                if(neighbors.second.concentration>500){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                }
                                else{
                                    concentration += neighbors.second.concentration;
                                }
                                num_neighbors +=1;

                            } 
                    }
                }
                new_state.concentration = concentration/num_neighbors;

                break;
            }
            case WORKSTATION:{
                int concentration = 0;
                int num_neighbors = 0;
                for(auto neighbors: state.neighbors_state) {
                    if( neighbors.second.concentration < 0){
                        assert(false && "co2 concentration cannot be negative");
                    }
                    if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
                        concentration += neighbors.second.concentration;
                        num_neighbors +=1;
                    }
                }
                new_state.concentration = concentration/num_neighbors;

                break;
            }
            case CO2_SOURCE:{
                int concentration = 0;
                int num_neighbors = 0;

                for(auto neighbors: state.neighbors_state) {
                    if( neighbors.second.concentration < 0){
                        assert(false && "co2 concentration cannot be negative");
                    }
                    if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
                        if (neighbors.first[0] == std::get<0>(currentLocation) && (neighbors.first[1] - 1) == std::get<1>(currentLocation)){
                                concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                num_neighbors +=1;
                            }
                            // Neighbor on right
                        else if((neighbors.first[0] - 1) == std::get<0>(currentLocation) && neighbors.first[1] == std::get<1>(currentLocation)){
                                concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                num_neighbors +=1;
                            }
                            // Neighbor on bottom
                        else if (neighbors.first[0] == std::get<0>(currentLocation) && (neighbors.first[1] + 1) == std::get<1>(currentLocation)){
                                concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                num_neighbors +=1;
                            }
                            // Neighbor on left
                        else if((neighbors.first[0] + 1) == std::get<0>(currentLocation) && neighbors.first[1] == std::get<1>(currentLocation)){
                                concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                num_neighbors +=1;
                            }
                            // itself
                        else if(neighbors.first[0] == std::get<0>(currentLocation) && neighbors.first[1] == std::get<1>(currentLocation)&& neighbors.first[2] == std::get<2>(currentLocation)){
                                concentration += neighbors.second.concentration;
                                num_neighbors +=1;
                            }
                            //above
                        else if((neighbors.first[2] - 1) == std::get<2>(currentLocation)){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                    num_neighbors +=1;
                            }
                            // behind
                        else if((neighbors.first[2] + 1) == std::get<2>(currentLocation)){
                                    concentration += neighbors.second.concentration + floor(neighbors.second.concentration*distneg(rng)/500 );
                                    num_neighbors +=1;

                            }
                    }
                }

                new_state.concentration = (concentration/num_neighbors) + (concentration_increase);
                new_state.counter += 1;

                break;
            }
            default:{
                assert(false && "should never happen");
            }
        }

        return new_state;

    }

    // It returns the delay to communicate cell's new state.
    T output_delay(co2 const &cell_state) const override {
        switch(cell_state.type){
            case CO2_SOURCE: return resp_time;
            default: return 1;
        }
    }

};

#endif //CADMIUM_CELLDEVS_CO2_CELL_HPP












